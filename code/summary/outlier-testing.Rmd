---
title: "Test outlier identification with Tukey's Rule"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
output: github_document
---

```{r setup, message=FALSE, include=FALSE}
knitr::opts_chunk$set(comment = NA)
```

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
source("../../R/outliers.R")
svy <- readRDS("../../data/interim/svy-weight.rds")

# exclude suspicious respondents
suspicious <- filter(svy$person, flag > 3)
svy <- lapply(svy, function(df) anti_join(df, suspicious, by = "Vrid"))
```

## Tukey's Test

We can apply [Tukey's test]( https://en.wikipedia.org/wiki/Outlier#Tukey%27s_fences) to identify outliers for overall days by activity. We end up with a rule that is very aggressive in identifying outliers.

```{r}
# identify outliers
days <- svy$act %>%
    group_by(act) %>%
    mutate(
        is_outlier = tukey_outlier(days, ignore_zero = TRUE),
        days_cleaned = ifelse(is_outlier, NA, days)
    ) %>%
    ungroup()

# plot
x <- filter(days, is_targeted, !is.na(days), days > 0)
x %>%
    ggplot(aes(act, days)) +
    geom_boxplot(outlier.size = -1) +
    geom_point(data = count(x, act, days, is_outlier), aes(size = n, color = is_outlier)) +
    scale_color_manual(values = c("gray", "red")) +
    ggtitle("Tukey's test")
```

A very large percentage are flagged for removal in every activity

```{r}
group_by(x, act, is_outlier) %>%
    summarise(n = n()) %>%
    mutate(pct_outliers = n / sum(n) * 100) %>%
    filter(is_outlier) %>%
    knitr::kable()
```

The outlier flagging has a very large effect on averages.

```{r}
days %>%
    filter(is_targeted) %>%
    group_by(act) %>%
    summarise_at(vars(days, days_cleaned), funs(mean(., na.rm = TRUE))) %>%
    knitr::kable()
```

## Log-transfrom with Tukey's Test

This is a much less aggressive rule.

```{r}
# identify outliers
days <- svy$act %>%
    group_by(act) %>%
    mutate(
        is_outlier = tukey_outlier(days, ignore_zero = TRUE, apply_log = TRUE),
        days_cleaned = ifelse(is_outlier, NA, days)
    ) %>%
    ungroup()

# plot
x <- filter(days, is_targeted, !is.na(days), days > 0)
x %>%
    ggplot(aes(act, days)) +
    geom_boxplot(outlier.size = -1) +
    geom_point(data = count(x, act, days, is_outlier), aes(size = n, color = is_outlier)) +
    scale_color_manual(values = c("gray", "red")) +
    scale_y_log10() +
    ggtitle("Tukey's test based on log-transformed values")
```

```{r}
group_by(x, act, is_outlier) %>%
    summarise(n = n()) %>%
    mutate(pct_outliers = n / sum(n) * 100) %>%
    filter(is_outlier) %>%
    knitr::kable()
```

The rule can still have a sizeable effect on averages:

```{r}
days %>%
    filter(is_targeted) %>%
    group_by(act) %>%
    summarise_at(vars(days, days_cleaned), funs(mean(., na.rm = TRUE))) %>%
    knitr::kable()
```

### Top-coding

Alternatively, we could topcode those values, which is a less aggressive approach:

```{r}
days2 <- days %>%
    group_by(act) %>%
    mutate(
        topcode_value = tukey_top(days, apply_log = TRUE, ignore_zero = TRUE),
        days_cleaned = ifelse(is_outlier, topcode_value, days)
    ) %>%
    ungroup()

days2 %>%
    filter(is_targeted) %>%
    group_by(act) %>%
    summarise_at(vars(days, days_cleaned), funs(mean(., na.rm = TRUE))) %>%
    knitr::kable()

days2 %>%
    filter(is_targeted) %>%
    count(act, topcode_value) %>% 
    knitr::kable()
```

